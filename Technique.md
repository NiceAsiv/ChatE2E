# 端到端加密方案实现

## 端到端加密概论

### 什么是端到端加密？

端对端加密（E2EE）是一种安全通信形式，在数据从一个终端系统传输到另一个终端系统期间，防止第三方的窥探或未经授权的访问。在E2EE中，通过发送方系统的数据是加密的，只能由接收方解密。在传输阶段，任何人都不能访问或篡改数据，包括互联网服务提供商（ISP）、应用服务提供商、第三方或黑客。

### 加密是如何运作的？

加密的运作原理是更改数据，以便只有拥有特定知识（即密钥）的人才能解释数据。假设 Alice 向 Bob 发送了一条消息，但 Chuck 在消息到达 Bob 的途中窃取了该消息。如果 Alice 使用她和 Bob 都拥有的密钥对消息进行加密，Chuck 就无法读取它，而 Alice 的消息仍然是安全的。相反，如果消息到达 Bob 处，Bob 能够使用他拥有的密钥解密消息，然后他可以阅读消息。

密钥可以在不同的环境中采用不同的形式。在上面的示例中，密钥可能就是一组用于解密 Alice 消息的指令，十分简单。对于互联网上的通信，密钥是一串位元，它在用于加密和解密数据的复杂数学方程式中发挥作用。

使用 E2EE，可以加密和解密消息的密钥仍然保存在用户的设备上。如果 Alice 和 Bob 使用一个 E2EE 消息传递应用程序，该应用程序会在 Alice 的手机上保存一个密钥，在 Bob 的手机上保存一个密钥。Alice 的手机用密钥加密她的消息，然后将加密的消息传输到 Bob 的手机。Bob 的手机会自动应用密钥并解密消息，从而允许 Bob 阅读它。

### 端到端加密如何支持隐私？

E2EE 确保除了正在相互通信的两个人之外，没有人可以看到消息（前提是他们使用的设备没有遭到入侵或被盗）。如果实施得当，它不需要用户相信服务会正确处理他们的数据。因此，E2EE 让人们可以完全控制谁可以阅读他们的消息，从而使他们能够保持消息的私密性。

### 端到端加密有哪些限制？

E2EE 确保消息在传输过程中的安全（当它们从一个人传递到另一个人时）。但是一旦消息到达目的地，它就不会再保护它们。

假设 Alice 和 Bob 正在使用 E2EE 应用程序，但 Chuck 偷了 Bob 的手机。现在 Chuck 可以看到 Alice 给 Bob 的消息了。如果 Chuck 不想费心去偷 Bob 的手机，他也可以偷偷溜到 Bob 身后，越过他的肩膀查看 Alice 的信息。或者，他可以尝试用恶意软件感染 Bob 的手机，以窃取 Alice 的消息。不管怎样，仅 E2EE 并不能保护 Bob 免受此类攻击。

最后，E2EE 不能保证是面向未来的。如果实施得当，现代加密方法足以抵抗来自世界上最强大的计算机的加密破解工作。但未来计算机可能会变得更强大。量子计算机如果得到发展，将能够破解现代加密算法。使用 E2EE 目前能够保证消息的安全，但可能无法永久保证消息的安全。

## Signal协议实现

`Signal 协议` 是一种真正的端到端加密（End-to-End Encryption）的通讯协议，号称是世界上最安全的通讯协议。只有参与通讯的用户可以读取并解密信息，而任何第三方（包括服务器）都无法查看到通讯的内容。

总的来说，它可以防止潜在的窃听者（包括：通信服务商、互联网服务提供商甚至是该通讯系统的提供者），获取能够用以解密通讯内容的密钥。

### 前向保密（Forward Secrecy）

在密码学中，前向保密（英语：Forward Secrecy，FS），有时也被称为完全前向保密（英语：Perfect Forward Secrecy，PFS），是密码学中通讯协议的安全属性，指的是长期使用的主密钥泄漏不会导致过去的会话密钥泄漏。

前向保密能够保护过去

进行的通讯不受密码或密钥在未来暴露的威胁。如果系统具有前向保密性，就可以保证在私钥泄露时历史通讯的安全，即使系统遭到主动攻击也是如此。

无论长期密钥，或者中期密钥，或者某轮密钥泄露，都不会导致之前的消息被破解。

### DH（Diffie-Hellman）

Diffie-Hellman 算法是 Whitefield Diffie 和 Martin Hellman 在1976年公布的一种秘钥交换算法，它是一种建立秘钥的方法，而不是加密方法，所以秘钥必须和其他一种加密算法结合使用。

这种秘钥交换技术的目的在于使两个用户安全的交换一个秘钥，以便后面的报文加密。

图1

图 5-8 表示 Diffie-Hellman 密钥交换过程 ,其中 , $p$是大素数 , a 是 p 的本原根 , p 和a作为公开的全程元素。用户 A 选择一个保密的随机整数 $X_\mathrm{A}$,并将 Ya$=a^{x_\mathrm{A}}\operatorname{mod}p$发送给用户 B。类似地，用户 B 选择一个保密的随机整数 $X_{\mathrm{в}}$,并将$Y_{\mathrm{в}}=a^{\mathrm{x}_{\mathrm{в}}\mathrm{mod}}p$发送给用户 A。然后 A 和 B 分别由$K=Y_{\mathrm{B}}^{\mathrm{x}}$ mod $p$和$K=Y_{\mathrm{A}}^{\mathrm{x}}$ mod $p$计算出的就是共享密钥



A的私钥 + B的公钥 = 密钥 = A的公钥 + B的私钥



![img](https://ask.qcloudimg.com/http-save/yehe-8223537/e03047afc96151c62f8a7a385107194f.png)

### ECDH

`ECC` 算法和 `DH` 结合使用，用于密钥磋商，这个密钥交换算法称为 `ECDH`，全称是**椭圆曲线迪菲-赫尔曼秘钥交换（Elliptic Curve Diffie–Hellman key Exchange）**，主要用来在一个不安全的通道中建立起安全的共有加密资料，一般来说交换的都是私钥，这个密钥一般作为“对称加密”的密钥而被双方在后续数据传输中使用。

`ECC` 是建立在基于椭圆曲线的离散对数问题上的密码体制，给定椭圆曲线上的一个点 $P$，一个整数 $k$，求解 $Q = kP$ 很容易；给定一个点$P$、$Q$，知道 $Q = kP$，求整数 $k$ 确是一个难题。

ECDH即建立在此数学难题之上。

### HMAC

全称 Hash-based Message Authentication Code，用于生成摘要，验证信息的完整性以及源身份。



### KDF

KDF 全称（Key Derivation Function）密钥导出函数。密码学中，密钥导出函数是指使用伪随机函数从秘密值（或者称为主密钥，就是一个原始的密钥）导出一个或多个密钥。

KDF 最常见的用途是将密码散列的方法来密码验证，也用作多方密钥协商协议的组成部分。

KDF一般可表示为：

$$ DK = KDF(Key, Salt, Iterations)$$

其中：
$DK$：派生密钥，
$KDF$：密钥导出函数；
$Key$：原始密钥或密码；
$Salt$：作为密码盐的随机数
$Iterations$：子功能的迭代次数。

### HKDF

`HKDF` 全称（HMAC-based KDF），基于 HMAC 的密钥推导函数，它可以应用于各种协议和应用程序的构建。

HKDF 的主要目的是使用原始的密钥材料，派生出一个或更多个能达到密码学强度的密钥（主要是保证随机性）——就是将较短的密钥材料扩展成较长的密钥材料，过程中需要保证随机性。

简单地说，就是

$$HKDF(key, salt, info) => T(0), T(1), T(2), T(..)$$







## 参考链接

[1] A. Langley, M. Hamburg, and S. Turner, “Elliptic Curves for Security.” Internet Engineering Task Force; RFC 7748 (Informational); IETF, Jan-2016. http://www.ietf.org/rfc/rfc7748.txt 

[2] https://signal.org/docs/specifications/doubleratchet/

[3] https://signal.org/docs/specifications/x3dh/

